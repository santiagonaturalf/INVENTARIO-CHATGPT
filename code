/**
 * @OnlyCurrentDoc
 */

/**
 * The sheet names used in the spreadsheet.
 * @enum {string}
 */
const SHEET_NAMES = {
  INVENTORY: 'Inventario',
  ACQUISITIONS: 'Adquisiciones',
  SALES: 'Ventas',
  SKU: 'SKU',
  DISCREPANCIES: 'Discrepancias',
  HISTORICAL_INVENTORY: 'Inventario HistÃ³rico',
  TODAY_REPORT: 'REPORTE HOY',
  // Esta es la hoja donde se guardan los reportes de clientes generados.
  REPORTED_CLIENTS: 'ReporteClientes',
};

/**
 * URLs for the external spreadsheets.
 * @enum {string}
 */
const SOURCE_URLS = {
  OPERACION: 'https://docs.google.com/spreadsheets/d/1hPyDsDHo6Sll6mYY_4YGcPJ4I9FPpG1kQINcidMM-s4/edit',
  ACQUISITIONS_SOURCE: 'https://docs.google.com/spreadsheets/d/1vCZejbBPMh73nbAhdZNYFOlvJvRoMA7PVSCUiLl8MMQ/edit?gid=1415653435#gid=1415653435',
};

/**
 * Creates the initial sheet structure and custom menu.
 * This function runs automatically when the spreadsheet is opened.
 */
function onOpen() {
  const ui = SpreadsheetApp.getUi();
  ui.createMenu('ðŸ“Š Inventario')
    .addItem('ðŸ”„ Sincronizar y Ver Dashboard', 'synchronizeInventoryUI')
    .addSeparator()
    .addItem('âœï¸ Actualizar Inventario', 'launchInventoryCompletion')
    .addItem('ðŸ“ Generar Reporte de Cliente', 'showReportGeneratorUI')
    .addSeparator()
    .addItem('âš¡ Forzar ActualizaciÃ³n de Datos', 'forceRefreshAllImports')
    .addItem('Simular Datos HistÃ³ricos', 'simulateHistoricalData')
    .addSeparator()
    .addItem('âš ï¸ Reiniciar Sistema (Puesta en Marcha Blanca)', 'resetSystem')
    .addToUi();

  createSheetsIfNeeded();
  setupImportFormulas();
}

/**
 * Creates the necessary sheets if they don't already exist.
 */
function createSheetsIfNeeded() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheetNames = Object.values(SHEET_NAMES);

  sheetNames.forEach(name => {
    if (!ss.getSheetByName(name)) {
      const newSheet = ss.insertSheet(name);
      if (name === SHEET_NAMES.ACQUISITIONS) {
        newSheet.appendRow(['Producto Base', 'Formato de Compra', 'Cantidad a Comprar', 'Correccion a Comprar', 'N Formato', 'N Cant', 'N Unidad']);
      } else if (name === SHEET_NAMES.DISCREPANCIES) {
        newSheet.appendRow(['Timestamp', 'Producto Base', 'Stock Esperado', 'Stock Real', 'Discrepancia', 'Unidad de Stock', 'Nota']);
      } else if (name === SHEET_NAMES.HISTORICAL_INVENTORY) {
        newSheet.appendRow(['Timestamp', 'Producto Base', 'Cantidad Stock Real', 'Unidad Venta']);
      } else if (name === SHEET_NAMES.TODAY_REPORT) {
        newSheet.appendRow(['SKU', 'Producto', 'Total Adquirido Hoy', 'Total Vendido Hoy', 'Stock Esperado', 'Ãšltimo Stock Real', 'Discrepancia', 'Notas']);
      } else if (name === SHEET_NAMES.INVENTORY) {
        newSheet.appendRow(['Producto Base', 'Ultimo Stock', 'Stock Esperado', 'Unidad de Stock', 'STOCK REAL HOY', 'CANTIDAD (ADQUISICIONES HOY)', 'FORMATO (ADQUISICIONES HOY)', 'CANTIDAD VENDIDA HOY', 'NOMBRE PRODUCTO']);
      } else if (name === SHEET_NAMES.REPORTED_CLIENTS) {
        newSheet.appendRow(['Fecha Reporte', 'NÂº Pedido', 'Nombre Cliente', 'TelÃ©fono', 'Email', 'Nombre Producto', 'Cantidad']);
      }
    }
  });
}

/**
 * Sets up the IMPORTRANGE formulas in the respective sheets.
 */
function setupImportFormulas() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const acquisitionsSheet = ss.getSheetByName(SHEET_NAMES.ACQUISITIONS);
  if (acquisitionsSheet.getRange('A2').getFormula() === '') {
    acquisitionsSheet.getRange('A2').setFormula('=IMPORTRANGE("' + SOURCE_URLS.ACQUISITIONS_SOURCE + '"; "RESUMEN_Adquisiciones!B2:D")');
  }
  if (acquisitionsSheet.getRange('D2').getFormula() === '') {
    acquisitionsSheet.getRange('D2').setFormula('=IMPORTRANGE("' + SOURCE_URLS.ACQUISITIONS_SOURCE + '"; "RESUMEN_Adquisiciones!I2:L")');
  }
  const salesSheet = ss.getSheetByName(SHEET_NAMES.SALES);
   if (salesSheet.getRange('A1').getFormula() === '') {
      salesSheet.getRange('A1').setFormula('=IMPORTRANGE("' + SOURCE_URLS.OPERACION + '"; "Orders!A:K")');
  }
  const skuSheet = ss.getSheetByName(SHEET_NAMES.SKU);
  if (skuSheet.getRange('A1').getFormula() === '') {
      skuSheet.getRange('A1').setFormula('=IMPORTRANGE("' + SOURCE_URLS.OPERACION + '"; "SKU!A:K")');
  }
}

/**
 * Forces a refresh of all IMPORTRANGE formulas by clearing and resetting them.
 * This function now clears the target sheets to prevent "array result was not expanded" errors.
 */
function forceRefreshAllImports() {
  const ui = SpreadsheetApp.getUi();
  ui.alert('Iniciando la actualizaciÃ³n forzada de datos. Esto puede tomar unos momentos...');

  const ss = SpreadsheetApp.getActiveSpreadsheet();

  try {
    // Handle sheets that are fully populated by IMPORTRANGE from A1
    const sheetsToClearFully = [SHEET_NAMES.SALES, SHEET_NAMES.SKU];
    sheetsToClearFully.forEach(sheetName => {
      const sheet = ss.getSheetByName(sheetName);
      if (sheet) {
        const cell = sheet.getRange('A1');
        const formula = cell.getFormula();
        if (formula && formula.toUpperCase().includes('IMPORTRANGE')) {
          sheet.clear(); // Clear the entire sheet
          SpreadsheetApp.flush();
          Utilities.sleep(1000);
          sheet.getRange('A1').setFormula(formula); // Restore formula
        }
      }
    });

    // Handle Acquisitions sheet which has headers in row 1
    const acqSheet = ss.getSheetByName(SHEET_NAMES.ACQUISITIONS);
    if (acqSheet) {
      // Store formulas before clearing
      const formulaA2 = acqSheet.getRange('A2').getFormula();
      const formulaD2 = acqSheet.getRange('D2').getFormula();

      // Clear from row 2 downwards
      if (acqSheet.getMaxRows() > 1) {
        acqSheet.getRange(2, 1, acqSheet.getMaxRows() - 1, acqSheet.getMaxColumns()).clearContent();
      }
      SpreadsheetApp.flush();
      Utilities.sleep(1000);

      // Restore formulas
      if (formulaA2 && formulaA2.toUpperCase().includes('IMPORTRANGE')) {
        acqSheet.getRange('A2').setFormula(formulaA2);
      }
      if (formulaD2 && formulaD2.toUpperCase().includes('IMPORTRANGE')) {
        acqSheet.getRange('D2').setFormula(formulaD2);
      }
    }

    SpreadsheetApp.flush();
    ui.alert('Â¡ActualizaciÃ³n forzada completada! Los datos deberÃ­an estar al dÃ­a.');
  } catch (e) {
    ui.alert('OcurriÃ³ un error durante la actualizaciÃ³n: ' + e.message);
  }
}

/**
 * Main entry point. Runs sync and then shows the main dashboard.
 */
function synchronizeInventoryUI() {
  const ui = SpreadsheetApp.getUi();
  try {
    synchronizeInventory();

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const inventorySheet = ss.getSheetByName(SHEET_NAMES.INVENTORY);
    const inventoryData = inventorySheet.getDataRange().getValues().slice(1);

    const skuData = ss.getSheetByName(SHEET_NAMES.SKU).getDataRange().getValues().slice(1);
    const converter = new SkuConverter(skuData);

    const inventoryByCategory = {};
    inventoryData.forEach(row => {
      const baseProduct = row[0];
      const category = converter.getCategory(baseProduct) || 'Sin CategorÃ­a';
      if (!inventoryByCategory[category]) {
        inventoryByCategory[category] = [];
      }
      inventoryByCategory[category].push(row);
    });

    const htmlTemplate = HtmlService.createTemplateFromFile('Dashboard');
    htmlTemplate.inventoryData = inventoryData;
    htmlTemplate.inventoryByCategory = inventoryByCategory;

    const html = htmlTemplate.evaluate().setWidth(900).setHeight(600);
    ui.showModalDialog(html, 'Dashboard de Inventario Diario');

  } catch (e) {
    ui.alert('Error al sincronizar y mostrar el dashboard: ' + e.message);
  }
}

// Wrapper functions to allow a modal to trigger another modal
function launchInventoryCompletion() {
  showInventoryCompletionUI();
}

function showReportGeneratorUI() {
  const html = HtmlService.createTemplateFromFile('ReportGenerator')
    .evaluate()
    .setWidth(800)
    .setHeight(800);
  SpreadsheetApp.getUi().showModalDialog(html, 'Generador de Reportes');
}

function getSalesDataForReporting() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const salesSheet = ss.getSheetByName(SHEET_NAMES.SALES);
    const salesData = salesSheet.getDataRange().getValues();
    const headers = salesData.shift(); // Remove headers

    const orders = salesData.reduce((acc, row) => {
      const orderId = row[0];
      if (!orderId) return acc;

      if (!acc[orderId]) {
        acc[orderId] = {
          orderId: orderId,
          clientName: row[1],
          email: row[2],
          phone: row[3],
          products: []
        };
      }
      acc[orderId].products.push({
        productName: row[9],
        quantity: row[10]
      });
      return acc;
    }, {});

    return Object.values(orders);
  } catch (e) {
    return { error: e.message };
  }
}

function getReportedClientsData() {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const reportSheet = ss.getSheetByName(SHEET_NAMES.REPORTED_CLIENTS);
    
    if (!reportSheet) {
      return []; 
    }

    const lastRow = reportSheet.getLastRow();
    if (lastRow < 2) {
      return [];
    }

    const data = reportSheet.getRange(2, 1, lastRow - 1, 7).getValues();

    return data.map(row => {
      const reportDate = row[0] instanceof Date ? row[0].toISOString().split('T')[0] : row[0];
      return {
        reportDate: reportDate,
        orderId: row[1],
        clientName: row[2],
        phone: row[3],
        email: row[4],
        productName: row[5],
        quantity: row[6]
      };
    });
  } catch (e) {
    console.error("Error in getReportedClientsData: " + e.message);
    return { error: e.message };
  }
}

function saveReport(reports) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const correctHeaders = ['Fecha Reporte', 'NÂº Pedido', 'Nombre Cliente', 'TelÃ©fono', 'Email', 'Nombre Producto', 'Cantidad'];
    let reportSheet = ss.getSheetByName(SHEET_NAMES.REPORTED_CLIENTS);

    if (!reportSheet) {
      reportSheet = ss.insertSheet(SHEET_NAMES.REPORTED_CLIENTS);
      reportSheet.getRange(1, 1, 1, correctHeaders.length).setValues([correctHeaders]);
    } else {
      if (reportSheet.getLastRow() === 0) {
        reportSheet.getRange(1, 1, 1, correctHeaders.length).setValues([correctHeaders]);
      } else {
        const currentHeaders = reportSheet.getRange(1, 1, 1, correctHeaders.length).getValues()[0];
        if (JSON.stringify(currentHeaders) !== JSON.stringify(correctHeaders)) {
          reportSheet.clear();
          reportSheet.getRange(1, 1, 1, correctHeaders.length).setValues([correctHeaders]);
          SpreadsheetApp.flush();
        }
      }
    }

    const lastRow = reportSheet.getLastRow();
    let existingOrderIds = new Set();
    if (lastRow > 1) {
      const orderIds = reportSheet.getRange(2, 2, lastRow - 1, 1).getValues().flat().filter(id => id);
      existingOrderIds = new Set(orderIds);
    }

    const newReports = reports.filter(report => !existingOrderIds.has(report.orderId));

    if (newReports.length === 0) {
      return { success: true, message: "Todos los pedidos seleccionados ya habÃ­an sido reportados. No se guardÃ³ nada nuevo." };
    }

    const reportDate = new Date();
    const rowsToAppend = [];
    newReports.forEach(report => {
      report.products.forEach(p => {
        rowsToAppend.push([
          reportDate,
          report.orderId,
          report.clientName,
          report.phone,
          report.email,
          p.productName,
          p.quantity
        ]);
      });
    });

    reportSheet.getRange(reportSheet.getLastRow() + 1, 1, rowsToAppend.length, rowsToAppend[0].length).setValues(rowsToAppend);

    const savedCount = newReports.length;
    const skippedCount = reports.length - savedCount;
    let message = `Se guardaron ${savedCount} nuevos reportes.`;
    if (skippedCount > 0) {
      message += ` Se omitieron ${skippedCount} reportes que ya existÃ­an.`;
    }

    return { success: true, message: message };
  } catch (e) {
    return { success: false, message: `Error al guardar los reportes: ${e.message}` };
  }
}

function synchronizeInventory() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();

  const acquisitionsData = ss.getSheetByName(SHEET_NAMES.ACQUISITIONS).getDataRange().getValues().slice(1);
  const salesData = ss.getSheetByName(SHEET_NAMES.SALES).getDataRange().getValues().slice(1);
  const skuData = ss.getSheetByName(SHEET_NAMES.SKU).getDataRange().getValues().slice(1);
  const historicalData = ss.getSheetByName(SHEET_NAMES.HISTORICAL_INVENTORY).getDataRange().getValues().slice(1);

  const converter = new SkuConverter(skuData);
  const acquisitionsByBase = new Map();
  const salesByBase = new Map();
  const salesSummaryByBase = new Map();
  const acquisitionsSummaryByBase = new Map();
  const allBaseProductsSet = new Set(converter.getAllBaseProducts());

  salesData.forEach(row => {
    const nombreProducto = row[9];
    if (!nombreProducto || typeof nombreProducto !== 'string') return;
    const quantitySold = parseFloat(row[10]);
    if (isNaN(quantitySold)) return;

    const saleInfo = converter.getSaleConversion(nombreProducto.trim());
    if (!saleInfo) return;
    const { baseProduct, amountInInventoryUnit } = saleInfo;
    allBaseProductsSet.add(baseProduct);
    const totalSoldInInventoryUnit = quantitySold * amountInInventoryUnit;
    salesByBase.set(baseProduct, (salesByBase.get(baseProduct) || 0) + totalSoldInInventoryUnit);
    if (!salesSummaryByBase.has(baseProduct)) salesSummaryByBase.set(baseProduct, new Map());
    const currentSummaryQty = salesSummaryByBase.get(baseProduct).get(nombreProducto.trim()) || 0;
    salesSummaryByBase.get(baseProduct).set(nombreProducto.trim(), currentSummaryQty + quantitySold);
  });

  acquisitionsData.forEach(row => {
    let [productoBase, formatoCompra, cantComprar, corrCant, corrFormato, corrNCant, corrNUnidad] = row;
    if (!productoBase || typeof productoBase !== 'string') return;
    const baseProductKey = productoBase.trim();
    allBaseProductsSet.add(baseProductKey);

    let totalAcquiredInInventoryUnit = 0;
    let acquisitionFormat = '';
    let acquisitionQty = 0;
    if (corrCant && corrFormato && typeof corrFormato === 'string' && corrNCant && corrNUnidad) {
      acquisitionQty = parseFloat(corrCant);
      const purchaseConversion = converter.getPurchaseConversion(baseProductKey, corrFormato.trim());
      totalAcquiredInInventoryUnit = acquisitionQty * purchaseConversion;
      acquisitionFormat = `${corrCant} ${corrFormato}`;
    } else if (formatoCompra && cantComprar) {
      acquisitionQty = parseFloat(cantComprar);
      const formatoName = SkuConverter.parsePurchaseFormat(formatoCompra);
      const purchaseConversion = converter.getPurchaseConversion(baseProductKey, formatoName);
      totalAcquiredInInventoryUnit = acquisitionQty * purchaseConversion;
      acquisitionFormat = formatoCompra;
    }
    if (totalAcquiredInInventoryUnit > 0) {
      acquisitionsByBase.set(baseProductKey, (acquisitionsByBase.get(baseProductKey) || 0) + totalAcquiredInInventoryUnit);
      if (!acquisitionsSummaryByBase.has(baseProductKey)) acquisitionsSummaryByBase.set(baseProductKey, []);
      acquisitionsSummaryByBase.get(baseProductKey).push({ qty: acquisitionQty, format: acquisitionFormat });
    }
  });

  const latestHistoricalStock = historicalData.reduce((map, row) => {
    let [timestamp, baseProduct, realStock] = row;
    if (baseProduct && typeof baseProduct === 'string' && timestamp) {
      const baseProductKey = baseProduct.trim();
      const ts = new Date(timestamp);
      if (!map.has(baseProductKey) || ts > map.get(baseProductKey).timestamp) {
        map.set(baseProductKey, { stock: parseFloat(realStock) || 0, timestamp: ts });
      }
    }
    return map;
  }, new Map());

  const inventorySheet = ss.getSheetByName(SHEET_NAMES.INVENTORY);
  const lastRow = inventorySheet.getLastRow();
  const realStockMap = new Map();
  if (lastRow > 1) {
    const oldData = inventorySheet.getRange(2, 1, lastRow - 1, 5).getValues();
    oldData.forEach(r => { if(r[0] && typeof r[0] === 'string') realStockMap.set(r[0].trim(), r[4]) });
  }

  const inventoryOutput = [];
  allBaseProductsSet.forEach(baseProduct => {
    const lastStockInfo = latestHistoricalStock.get(baseProduct);
    const lastStock = lastStockInfo ? lastStockInfo.stock : 0;
    const lastStockString = lastStockInfo ? `${lastStockInfo.stock} (${lastStockInfo.timestamp.toLocaleDateString()})` : 'N/A';
    const acquiredTotal = acquisitionsByBase.get(baseProduct) || 0;
    const soldTotal = salesByBase.get(baseProduct) || 0;
    const expectedStock = lastStock + acquiredTotal - soldTotal;
    const inventoryUnit = converter.getInventoryUnit(baseProduct);
    const realStock = realStockMap.get(baseProduct) || '';
    const acqSummaries = acquisitionsSummaryByBase.get(baseProduct) || [];
    const acqQtyStr = acqSummaries.map(s => s.qty).join(', ');
    const acqFormatStr = acqSummaries.map(s => s.format).join(', ');
    const salesSummaryMap = salesSummaryByBase.get(baseProduct);
    const salesSummaryStr = salesSummaryMap ? [...salesSummaryMap.entries()].map(([name, qty]) => `${name} (${qty})`).join(', ') : '';
    inventoryOutput.push([
      baseProduct, lastStockString, expectedStock, inventoryUnit, realStock,
      acqQtyStr, acqFormatStr, soldTotal, salesSummaryStr
    ]);
  });

  inventorySheet.getRange(2, 1, inventorySheet.getMaxRows() - 1, 9).clearContent();
  if (inventoryOutput.length > 0) {
    inventorySheet.getRange(2, 1, inventoryOutput.length, inventoryOutput[0].length).setValues(inventoryOutput);
  }
}

function showInventoryCompletionUI() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const ui = SpreadsheetApp.getUi();
  try {
    synchronizeInventory();
    const inventorySheet = ss.getSheetByName(SHEET_NAMES.INVENTORY);
    const inventoryData = inventorySheet.getDataRange().getValues().slice(1);
    const skuData = ss.getSheetByName(SHEET_NAMES.SKU).getDataRange().getValues().slice(1);
    const converter = new SkuConverter(skuData);

    // Filter for products with movement (sales or acquisitions)
    const productsWithMovement = inventoryData.filter(row => {
      const acquiredQty = row[5]; // CANTIDAD (ADQUISICIONES HOY)
      const soldQty = row[7];     // CANTIDAD VENDIDA HOY
      return (acquiredQty && parseFloat(acquiredQty) > 0) || (soldQty && parseFloat(soldQty) > 0);
    });

    // Group products by category
    const productsByCategory = productsWithMovement.reduce((acc, row) => {
      const baseProduct = row[0];
      const category = converter.getCategory(baseProduct) || 'Sin CategorÃ­a';

      if (!acc[category]) {
        acc[category] = [];
      }

      acc[category].push({
        baseProduct: baseProduct,
        expectedStock: row[2],
        baseUnit: row[3],
        acquiredToday: row[5] || '0',
        soldToday: row[7] || '0'
      });

      return acc;
    }, {});

    // Sort categories alphabetically
    const sortedCategories = Object.keys(productsByCategory).sort((a, b) => a.localeCompare(b));

    // Sort products within each category alphabetically
    for (const category in productsByCategory) {
        productsByCategory[category].sort((a, b) => a.baseProduct.localeCompare(b.baseProduct));
    }

    const htmlTemplate = HtmlService.createTemplateFromFile('InventoryCompletion');
    htmlTemplate.productsByCategory = productsByCategory;
    htmlTemplate.sortedCategories = sortedCategories; // Pass sorted keys for the view

    const html = htmlTemplate.evaluate().setWidth(1200).setHeight(700);
    ui.showModalDialog(html, 'Completar Inventario (Productos con Movimiento)');
  } catch (e) {
    ui.alert('Error al abrir la ventana de inventario: ' + e.message);
  }
}

// Helper function to check if two dates are on the same day
function isSameDay(date1, date2) {
  if (!date1 || !date2) return false;
  return date1.getFullYear() === date2.getFullYear() &&
         date1.getMonth() === date2.getMonth() &&
         date1.getDate() === date2.getDate();
}

function processInventoryCount(inventoryDataFromModal) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const historicalSheet = ss.getSheetByName(SHEET_NAMES.HISTORICAL_INVENTORY);
  const discrepanciesSheet = ss.getSheetByName(SHEET_NAMES.DISCREPANCIES);
  const inventorySheet = ss.getSheetByName(SHEET_NAMES.INVENTORY);
  const reportSheet = ss.getSheetByName(SHEET_NAMES.TODAY_REPORT);
  const skuData = ss.getSheetByName(SHEET_NAMES.SKU).getDataRange().getValues().slice(1);
  const converter = new SkuConverter(skuData);
  const timestamp = new Date();

  // Get current state from Inventario sheet
  const fullInventoryData = inventorySheet.getDataRange().getValues().slice(1);
  const inventoryMap = new Map(fullInventoryData.map(row => [row[0], row])); // Map by Producto Base

  const newHistoricalRows = [];
  const newDiscrepancyRows = [];
  const reportRows = [];

  inventoryDataFromModal.forEach(item => {
    const baseProduct = item.baseProduct.trim();
    const actualStock = parseFloat(item.actualStock);
    const note = item.note || '';
    const inventoryRow = inventoryMap.get(baseProduct);

    if (inventoryRow && !isNaN(actualStock)) {
      const expectedStock = parseFloat(inventoryRow[2]);
      const discrepancy = actualStock - expectedStock;
      const inventoryUnit = inventoryRow[3];
      const sku = converter.getSku(baseProduct) || '';
      const acquiredToday = inventoryRow[5]; // CANTIDAD (ADQUISICIONES HOY) is at index 5
      const soldToday = inventoryRow[7]; // Total Vendido Hoy is at index 7

      // 1. Prepare row for REPORTE HOY
      reportRows.push([
        sku,
        baseProduct,
        acquiredToday,
        soldToday,
        expectedStock,
        actualStock,
        discrepancy,
        note
      ]);

      // 2. Prepare row for Discrepancias (if any)
      if (discrepancy !== 0) {
        newDiscrepancyRows.push([timestamp, baseProduct, expectedStock, actualStock, discrepancy, inventoryUnit, note]);
      }

      // 3. Prepare row for Inventario HistÃ³rico
      newHistoricalRows.push([timestamp, baseProduct, actualStock, inventoryUnit]);

      // 4. Update STOCK REAL HOY in Inventario sheet
      const rowToUpdate = fullInventoryData.findIndex(r => r[0] === baseProduct) + 2;
      if (rowToUpdate > 1) {
        inventorySheet.getRange(rowToUpdate, 5).setValue(actualStock);
      }
    }
  });

  // --- Overwrite logic for Inventario HistÃ³rico ---
  if (historicalSheet.getLastRow() > 1) {
    const allHistoricalData = historicalSheet.getRange(2, 1, historicalSheet.getLastRow() - 1, 4).getValues();
    const pastHistoricalData = allHistoricalData.filter(row => row[0] && !isSameDay(new Date(row[0]), timestamp));
    const updatedHistoricalData = [...pastHistoricalData, ...newHistoricalRows];
    historicalSheet.getRange(2, 1, historicalSheet.getMaxRows() - 1, historicalSheet.getMaxColumns()).clearContent();
    if (updatedHistoricalData.length > 0) {
      historicalSheet.getRange(2, 1, updatedHistoricalData.length, updatedHistoricalData[0].length).setValues(updatedHistoricalData);
    }
  } else if (newHistoricalRows.length > 0) {
    historicalSheet.getRange(2, 1, newHistoricalRows.length, newHistoricalRows[0].length).setValues(newHistoricalRows);
  }

  // --- Overwrite logic for Discrepancias ---
  if (discrepanciesSheet.getLastRow() > 1) {
    const allDiscrepancyData = discrepanciesSheet.getRange(2, 1, discrepanciesSheet.getLastRow() - 1, 7).getValues();
    const pastDiscrepancyData = allDiscrepancyData.filter(row => row[0] && !isSameDay(new Date(row[0]), timestamp));
    const updatedDiscrepancyData = [...pastDiscrepancyData, ...newDiscrepancyRows];
    discrepanciesSheet.getRange(2, 1, discrepanciesSheet.getMaxRows() - 1, discrepanciesSheet.getMaxColumns()).clearContent();
    if (updatedDiscrepancyData.length > 0) {
        discrepanciesSheet.getRange(2, 1, updatedDiscrepancyData.length, updatedDiscrepancyData[0].length).setValues(updatedDiscrepancyData);
    }
  } else if (newDiscrepancyRows.length > 0) {
      discrepanciesSheet.getRange(discrepanciesSheet.getLastRow() + 1, 1, newDiscrepancyRows.length, newDiscrepancyRows[0].length).setValues(newDiscrepancyRows);
  }

  // --- REPORTE HOY logic (remains the same) ---
  const reportHeader = ['SKU', 'Producto', 'Total Adquirido Hoy', 'Total Vendido Hoy', 'Stock Esperado', 'Ãšltimo Stock Real', 'Discrepancia', 'Notas'];
  reportSheet.getRange(1, 1, 1, reportHeader.length).setValues([reportHeader]);
  reportSheet.getRange(2, 1, reportSheet.getMaxRows() - 1, reportHeader.length).clearContent();
  if (reportRows.length > 0) {
    reportSheet.getRange(2, 1, reportRows.length, reportRows[0].length).setValues(reportRows);
  }
}

function generateTodaysReport() {
    SpreadsheetApp.getUi().alert('Esta funciÃ³n ha sido eliminada y su funcionalidad integrada en la hoja "Inventario".');
}

function simulateHistoricalData() {
  const ui = SpreadsheetApp.getUi();
  try {
    synchronizeInventory();

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const historicalSheet = ss.getSheetByName(SHEET_NAMES.HISTORICAL_INVENTORY);
    const inventorySheet = ss.getSheetByName(SHEET_NAMES.INVENTORY);
    const inventoryData = inventorySheet.getDataRange().getValues().slice(1);

    if (inventoryData.length === 0) {
      ui.alert('No hay datos en la hoja "Inventario" para simular. Sincroniza primero.');
      return;
    }

    const historicalRows = [];
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);

    inventoryData.forEach(row => {
      const [baseProduct, , , inventoryUnit] = row;
      const simulatedStock = Math.floor(Math.random() * 10) + 1;
      historicalRows.push([yesterday, baseProduct, simulatedStock, inventoryUnit]);
    });

    if (historicalRows.length > 0) {
      historicalSheet.getRange(historicalSheet.getLastRow() + 1, 1, historicalRows.length, historicalRows[0].length).setValues(historicalRows);
      ui.alert('Se han generado ' + historicalRows.length + ' registros de prueba para "ayer" en "Inventario HistÃ³rico".');
    } else {
      ui.alert('No se generaron datos.');
    }
  } catch (e) {
    ui.alert('Error al simular datos: ' + e.message);
  }
}


function resetSystem() {
  const ui = SpreadsheetApp.getUi();
  const response = ui.prompt(
    'ConfirmaciÃ³n de Reinicio Total',
    'Esta acciÃ³n borrarÃ¡ los datos de inventario y discrepancias. Es irreversible. Por favor, introduce la clave "11" para confirmar.',
    ui.ButtonSet.OK_CANCEL
  );

  if (response.getSelectedButton() == ui.Button.OK && response.getResponseText() == '11') {
    ui.alert('Clave correcta. Iniciando el proceso de reinicio...');
    try {
      const ss = SpreadsheetApp.getActiveSpreadsheet();
      const sheetsToClear = [SHEET_NAMES.INVENTORY, SHEET_NAMES.HISTORICAL_INVENTORY, SHEET_NAMES.DISCREPANCIES];

      sheetsToClear.forEach(name => {
        const sheet = ss.getSheetByName(name);
        if (sheet) {
          const range = sheet.getRange(2, 1, sheet.getMaxRows() - 1, sheet.getMaxColumns());
          range.clearContent();
        }
      });

      forceRefreshAllImports();

      // Give some time for imports to refresh before syncing
      Utilities.sleep(5000);

      synchronizeInventory();

      ui.alert('Â¡Reinicio completado! El sistema estÃ¡ listo para un nuevo dÃ­a.');

    } catch (e) {
      ui.alert('OcurriÃ³ un error durante el reinicio: ' + e.message);
    }
  } else {
    ui.alert('La clave es incorrecta o la operaciÃ³n fue cancelada. No se ha realizado ningÃºn cambio.');
  }
}

/**
 * Cleans a phone number string by removing non-numeric characters.
 * @param {string} phone The phone number to clean.
 * @returns {string} A string containing only digits.
 */
function normalizePhoneNumber(phone) {
  if (!phone || typeof phone.toString !== 'function') {
    return '';
  }
  return phone.toString().replace(/\D/g, '');
}

class SkuConverter {
  constructor(skuData) {
    this.inventoryUnitMap = new Map(); // Maps Producto Base -> Unidad Venta
    this.salesConversionMap = new Map(); // Maps Nombre Producto -> { baseProduct, amountInInventoryUnit }
    this.purchaseConversionMap = new Map(); // Maps Producto Base -> Formato -> amountInInventoryUnit
    this.categoryMap = new Map(); // Maps Producto Base -> Categoria
    this.baseProductToSkuMap = new Map(); // Maps Producto Base -> Nombre Producto (SKU)

    this._buildMaps(skuData);
  }

  _buildMaps(skuData) {
    // Pass 1: Determine the standard inventory unit, Category, and SKU for each Producto Base.
    skuData.forEach(row => {
      const [nombreProducto, productoBase, , , , categoria, , unidadVenta] = row;
      if (productoBase && typeof productoBase === 'string') {
        const baseProductKey = productoBase.trim();
        if (unidadVenta && typeof unidadVenta === 'string' && !this.inventoryUnitMap.has(baseProductKey)) {
          this.inventoryUnitMap.set(baseProductKey, unidadVenta.trim());
        }
        if (categoria && typeof categoria === 'string' && !this.categoryMap.has(baseProductKey)) {
          this.categoryMap.set(baseProductKey, categoria.trim());
        }
        if (nombreProducto && typeof nombreProducto === 'string' && !this.baseProductToSkuMap.has(baseProductKey)) {
          this.baseProductToSkuMap.set(baseProductKey, nombreProducto.trim());
        }
      }
    });

    // Pass 2: Build the conversion maps.
    skuData.forEach(row => {
      const [nombreProducto, productoBase, formato, cantCompra, unidadCompra, , cantVenta, unidadVenta] = row;

      // Sales Conversion
      if (nombreProducto && typeof nombreProducto === 'string' && productoBase && typeof productoBase === 'string' && cantVenta && unidadVenta) {
        const baseProductKey = productoBase.trim();
        const inventoryUnit = this.getInventoryUnit(baseProductKey);
        const convertedAmount = this.convert(parseFloat(cantVenta), unidadVenta, inventoryUnit);
        this.salesConversionMap.set(nombreProducto.trim(), {
          baseProduct: baseProductKey,
          amountInInventoryUnit: convertedAmount
        });
      }

      // Purchase Conversion
      if (productoBase && typeof productoBase === 'string' && formato && typeof formato === 'string' && cantCompra && unidadCompra) {
        const baseProductKey = productoBase.trim();
        if (!this.purchaseConversionMap.has(baseProductKey)) {
          this.purchaseConversionMap.set(baseProductKey, new Map());
        }
        const inventoryUnit = this.getInventoryUnit(baseProductKey);
        const convertedAmount = this.convert(parseFloat(cantCompra), unidadCompra, inventoryUnit);
        this.purchaseConversionMap.get(baseProductKey).set(formato.trim(), convertedAmount);
      }
    });
  }

  getInventoryUnit(baseProduct) {
    return this.inventoryUnitMap.get(baseProduct) || 'Unidad';
  }

  getCategory(baseProduct) {
    return this.categoryMap.get(baseProduct) || null;
  }

  getSku(baseProduct) {
    return this.baseProductToSkuMap.get(baseProduct) || null;
  }

  getSaleConversion(nombreProducto) {
    return this.salesConversionMap.get(nombreProducto) || null;
  }

  getPurchaseConversion(productoBase, formato) {
    if (this.purchaseConversionMap.has(productoBase)) {
      return this.purchaseConversionMap.get(productoBase).get(formato) || 0;
    }
    return 0;
  }

  getAllBaseProducts() {
    return [...this.inventoryUnitMap.keys()];
  }

  convert(amount, fromUnit, toUnit) {
    if (!fromUnit || !toUnit || fromUnit.toLowerCase() === toUnit.toLowerCase()) {
      return amount;
    }
    const unitMap = { 'kilo': 1000, 'kg': 1000, 'grs': 1, 'gr': 1, 'g': 1 };
    const from = fromUnit.toLowerCase();
    const to = toUnit.toLowerCase();
    if (unitMap[from] && unitMap[to]) {
      const amountInGrams = amount * unitMap[from];
      return amountInGrams / unitMap[to];
    }
    return amount;
  }

  static parsePurchaseFormat(formatString) {
    if (!formatString || typeof formatString !== 'string') return null;
    const match = formatString.match(/([^\(]+)/);
    if (match) {
      return match[1].trim();
    }
    return formatString.trim();
  }
}
